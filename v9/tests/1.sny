fun main() {
  let input = '123'

  let regexs = [
    RegEx::new(r'^\d$')
    RegEx::new(r'^\w$')
  ]

  assert(regexs.some(/regex/ regex.matches(input)))
  assert(regexs.which(/regex/ regex.matches(input)) == 1)
  assert(regexs.which_ones(/regex/ regex.matches(input)) == [1])
}

fun Vec<T>::some(self, predicate: fun (T) -> bool) -> bool {
  for value in self {
    if predicate(value) {
      return true
    }
  }
  return false
}

fun Vec<T>::some_is<O>(self, other: O) -> bool
where
  T: Eq<O>
{
  for value in self {
    if value == other {
      return true
    }
  }
}

fun assert(expr: bool, message := "") {
  if !expr {
    let why = message.is_empty()
      ? "Assertion failed"
      : message
    throw AssertionError::new(why)
  }
}

const fun debug_assert(expr: bool) {
  use terminal::{ green, red }
  let color = expr ? green : red
  println(color(stringify(expr)))
}

fun Vec<T>::with_each(self, change: fun (T) -> T) -> Self {
  let new: T[self.len()] = []
  for value in self {
    new.push(change(value))
  }
  return new
}

fun Vec<T>::map(self, change: fun (T) -> T) -> Self {
  for (i, value) in self.iter().enumerate() {
    self.set(i, change(value))
  }
  return self
}

fun Vec<T>::set(self, index: Integer, value: T) -> Result<(), MemoryError> {
  if index.abs() < self.len() {
    return Err(MemoryError::InvalidIndex)
  }
  let index: usize = index.is_negative()
    ? self.len() + index
    : index.into()
  set_bytes_at(self.ptr + size_of<T>() * index, value)!!
  return Ok(())
}

# idk, just keep this private
class Function<G, A, O> {
  struct {
    name: String,
    generics: Generic[]
    args: Argument[],
    output: Struct
  }
  struct Generic<T> {
    type = T,
    default: T,
    implements: Model[]
  }
  struct Argument<T> {
    type = T,
    default: T
  }

  # this is the `a()` expression
  internal fun call(generics, args) -> O {}

  # this prevents crashing the program
  fun try(a, b) -> Result<O, Error> {}
}

class Test {
  pub typedef TestFunction = fun () -> ()
  fun test(f: TestFunction, { super }: Context, name: ToString = "") -> TestFunction {
    let name = name.or(f'{super.name}::{f.name}')
    let passed = f.try().is_ok()
    println(f'{bold(name)}: {passed ? green('Ok') : red('Failed')}')
    # add execution time, exit code
  }
}

model Display {
  fun display(self) -> String
  fun pretty_display(self) -> String
}

# inspired by the behavior of the '||' operator in JavaScript
fun String::or(self, other: Display) -> String {
  return self.is_empty()
    ? other.display()
    : self
}

@test("Vec::set")
fun does_it_work() {
  let vec = [1, 2, 3]
  vec.set(0, 9)
  assert(vec == [9, 2, 3])
  vec.set((-1), 5)
  assert(vec == [9, 2, 5])
}

fun println(data: Display) {
  sys::stdout()
    .write(data.display())
    .write(sys::LINE_ENDING)
    .flush()
}

fun eprintln(data: Display) {
  sys::stderr()
    .write(data.display())
    .write(sys::LINE_ENDING)
    .flush()
}

@consecutive
fun eprintln(data: Display[]) {
  let stderr = sys::stderr();
  for value in data {
    stderr
      .write(value.display())
      .write(sys::LINE_ENDING)
  }
  stderr.flush()
}

# just a representation
const fun throw(value: Error) {
  eprintln(value.display())
  eprintln(sys::TAB)
  eprintln(f"at {src!()}:{line!()}:{column!()}")
  process::exit(1)
}

